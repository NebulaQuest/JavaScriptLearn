1. ` var a = 1 ` 的执行内容
   1. 先在作用域内询问是否有同名的变量，如果有重名的内容，编译器会直接忽略然后继续编译。如果没有就会在存储中声明一个变量，然后命名为a
   2. 接下来编译器就会寻找a这个变量，如果找到了那么就会将2进行赋值，如果没找到，就会抛出异常。
2. 理解 ` LHS` 和 ` RHS` 
   1. 分别表示的是赋值操作的左侧和右侧
   2. LHS 表示的是var a，印证的是1中的a行为，是找到a这个变量。我认为是创建变量的过程，如果找不到会直接创建这个变量，但是是 ` undefind `类型（非严格模式的情况下，在严格模式的情况下依然会报错）
   3. RHS表示的 a=1，这个是真正的赋值的过程，必须用到a这个变量，如果找不到就会报错
3. ** 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。  **

1. 作用域中的

 eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。  也就是说会被当做一个赋值语句进行使用，这叫做**欺骗作用域 **但是在严格模式下 ` eval() ` 有自己的词法作用域，所以并不一定会发生想要的结果

2.  **最小授权或最小暴露原则**。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。  
3.  `(function foo(){ .. }) `作为函数表达式意味着 foo 只能在 .. 所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作 用域。  只有以`function`开头的才是一个函数，否则都是函数表达式，这种函数表达式只存在自己声明的作用域内。回调函数就是最好的例子
4.  由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个 ( ) 可以立即执行这个函数，比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表 达式，第二个 ( ) 执行了这个函数。**立即执行函数表达式  ，**也可以第二个（）放到第一个（）里面，意思一样
5. 同时 `try{}catch(){}`中`catch`包裹的地方也是一个独立的作用域，比如捕获到的err只能在作用域内使用，外面无法访问。
6. **let**
   1. 这个关键字声明的变量只能说名是一个局部变量，因为在作用域声明的时候只能被作用域内部进行访问，无法从外部进行访问。而 `var`声明的内容，会直接进行变量提升，提升到最外层作用域。
## 作用域提升
```javascript
a = 2;
var a;
console.log( a );// 2

```
```javascript
console.log( a );// undefind
var a = 2;
```

第一个是因为a的时候会执行LHS 找不到a，就会创建一个a并赋值为`undefind` 然后执行RHS赋值操作，然后进行第二行，创建变量，进行LHS 找到变量，那么就进行下一步
第二个，就更简单了，先输出a，执行LHS操作，输出`undefind`
** 编译阶段中的一部分工作就是找到所有的 声明，并用合适的作用域将它们关联起来 , 包括变量和函数在内的所有声明都会在任何代码被执行前,首先被处理  **

## 闭包

1. 闭包可以让变量在所在作用域外面被访问到
```javascript
function wait(message) {
setTimeout( function timer() {
console.log( message );
}, 1000 );
}
wait( "Hello, closure!" );
```
这个里面，timer 就被wait 形成了一个闭包。这样的话就可以在外部变量中访问到内部变量timer的值，所以，在执行垃圾回收机制的时候，timer是不会被回收的，可以通过一个变量访问到。

```javascript
for (var i=1; i<=5; i++) {
setTimeout( function timer() {
console.log( i );
}, i*1000 );
}
```
 正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。 但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。 
setTimeout 是延迟执行函数，他会在循环结束之后执行，因为他们找 ` i` 的时候都是在全局作用域中查找，所以都是6.
只要改为let 就会达到想要的结果
** 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时 就产生了闭包。  ** 
